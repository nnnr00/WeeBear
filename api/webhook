import { Bot, InlineKeyboard, Keyboard } from 'grammy';
import { getDatabase } from '../lib/database';
import { formatBeijingTime, isAdmin, generateDeepLink } from '../lib/utils';

const bot = new Bot(process.env.BOT_TOKEN);
const db = getDatabase();
const ADMIN_IDS = process.env.ADMIN_IDS?.split(',').map(id => parseInt(id)) || [];
const GROUP_LINK = 'https://t.me/+495j5rWmApsxYzg9';

// ç”¨æˆ·çŠ¶æ€ç®¡ç†
const userStates = new Map();

// åˆå§‹åŒ–æ•°æ®åº“
async function initDB(userId) {
  const userData = await db.get(`user:${userId}`) || {};
  if (!userData.first_seen) {
    userData.first_seen = formatBeijingTime(new Date());
    userData.date_key = formatBeijingTime(new Date(), 'date');
    await db.set(`user:${userId}`, userData);
  }
  return userData;
}

// /start å‘½ä»¤
bot.command('start', async (ctx) => {
  const userId = ctx.from.id;
  const param = ctx.match;
  
  await initDB(userId);
  
  // å¤„ç†æ·±é“¾æ¥
  if (param === 'dh') {
    return handleDH(ctx);
  }
  
  const keyboard = new InlineKeyboard()
    .text('ğŸ’ åŠ å…¥ä¼šå‘˜ï¼ˆæ–°æ˜¥ç‰¹ä»·ï¼‰', 'vip_purchase')
    .row()
    .text('ğŸ å…‘æ¢', 'redeem');
  
  await ctx.reply(
    `ğŸŠ *å–œè¿é©¬å¹´æ–°æ˜¥* ğŸŠ\n` +
    `âœ¨ *èµ„æºå…è´¹è·å–* âœ¨\n\n` +
    `ğŸ§§ æ–°æ˜¥ç¦åˆ©æ´»åŠ¨è¿›è¡Œä¸­ ğŸ§§\n` +
    `ğŸ“± é€‰æ‹©æ‚¨éœ€è¦çš„æœåŠ¡ï¼š`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
});

// Admin é¢æ¿
bot.command('admin', async (ctx) => {
  if (!isAdmin(ctx.from.id, ADMIN_IDS)) {
    return ctx.reply('âŒ æ‚¨æ²¡æœ‰æƒé™è®¿é—®æ­¤åŠŸèƒ½');
  }
  
  const keyboard = new InlineKeyboard()
    .text('ğŸ“ è·å–File ID', 'admin_fileid')
    .row()
    .text('ğŸ“¦ å•†å“æ·»åŠ ', 'admin_products')
    .row()
    .text('ğŸ“‹ å·¥å•', 'admin_tickets')
    .row()
    .text('ğŸ‘¥ ç”¨æˆ·è¡¨', 'admin_users');
  
  await ctx.reply('ğŸ‘¨â€ğŸ’¼ *ç®¡ç†å‘˜é¢æ¿*', {
    parse_mode: 'Markdown',
    reply_markup: keyboard
  });
});

// VIPè´­ä¹°æµç¨‹
bot.callbackQuery('vip_purchase', async (ctx) => {
  await ctx.answerCallbackQuery();
  
  const keyboard = new InlineKeyboard()
    .text('âœ… æˆ‘å·²ä»˜æ¬¾ï¼Œå¼€å§‹éªŒè¯', 'verify_payment');
  
  await ctx.editMessageText(
    `ğŸŠ *å–œè¿æ–°æ˜¥ç‰¹ä»·* ğŸŠ\n\n` +
    `ğŸ’ *VIPä¼šå‘˜ç‰¹æƒè¯´æ˜ï¼š*\n` +
    `âœ… ä¸“å±ä¸­è½¬é€šé“\n` +
    `âœ… ä¼˜å…ˆå®¡æ ¸å…¥ç¾¤\n` +
    `âœ… 7x24å°æ—¶å®¢æœæ”¯æŒ\n` +
    `âœ… å®šæœŸç¦åˆ©æ´»åŠ¨\n\n` +
    `ğŸ’° æ–°æ˜¥ç‰¹ä»·ï¼šÂ¥99/å¹´\n` +
    `ğŸ“± æ”¯ä»˜æ–¹å¼ï¼šæ”¯ä»˜å®/å¾®ä¿¡`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
  
  // å‘é€æ”¯ä»˜äºŒç»´ç ï¼ˆå¦‚æœæœ‰file_idï¼‰
  const paymentFileId = await db.get('payment_qr_file_id');
  if (paymentFileId) {
    await ctx.replyWithPhoto(paymentFileId);
  }
});

// éªŒè¯æ”¯ä»˜
bot.callbackQuery('verify_payment', async (ctx) => {
  await ctx.answerCallbackQuery();
  const userId = ctx.from.id;
  
  userStates.set(userId, { state: 'awaiting_order' });
  
  await ctx.editMessageText(
    `ğŸ“ *è®¢å•éªŒè¯æŒ‡å¼•*\n\n` +
    `è¯·æŒ‰ä»¥ä¸‹æ­¥éª¤æŸ¥æ‰¾è®¢å•å·ï¼š\n` +
    `1ï¸âƒ£ æ‰“å¼€æ”¯ä»˜åº”ç”¨\n` +
    `2ï¸âƒ£ ç‚¹å‡» "æˆ‘çš„" â†’ "è´¦å•"\n` +
    `3ï¸âƒ£ æ‰¾åˆ°åˆšæ‰çš„ä»˜æ¬¾è®°å½•\n` +
    `4ï¸âƒ£ ç‚¹å‡» "è´¦å•è¯¦æƒ…"\n` +
    `5ï¸âƒ£ ç‚¹å‡» "æ›´å¤š" æŸ¥çœ‹è®¢å•å·\n` +
    `6ï¸âƒ£ å¤åˆ¶å®Œæ•´è®¢å•å·\n\n` +
    `â¬‡ï¸ *è¯·è¾“å…¥æ‚¨çš„è®¢å•å·ï¼š*`,
    { parse_mode: 'Markdown' }
  );
});

// å¤„ç†è®¢å•å·éªŒè¯
bot.on('message:text', async (ctx) => {
  const userId = ctx.from.id;
  const userState = userStates.get(userId);
  const text = ctx.message.text;
  
  // ç®¡ç†å‘˜è·å–File ID
  if (userState?.state === 'awaiting_file' && isAdmin(userId, ADMIN_IDS)) {
    userStates.delete(userId);
    return ctx.reply('âŒ è¯·å‘é€å›¾ç‰‡æ–‡ä»¶');
  }
  
  // éªŒè¯è®¢å•å·
  if (userState?.state === 'awaiting_order') {
    if (text.startsWith('20260')) {
      // éªŒè¯æˆåŠŸ
      userStates.delete(userId);
      
      // åˆ›å»ºå·¥å•
      const ticket = {
        userId,
        username: ctx.from.username || 'Unknown',
        firstName: ctx.from.first_name,
        orderId: text,
        time: formatBeijingTime(new Date()),
        status: 'pending'
      };
      
      const tickets = await db.get('tickets') || [];
      tickets.push(ticket);
      await db.set('tickets', tickets);
      
      // é€šçŸ¥ç®¡ç†å‘˜
      for (const adminId of ADMIN_IDS) {
        try {
          await bot.api.sendMessage(adminId,
            `ğŸ« *æ–°å·¥å•é€šçŸ¥*\n\n` +
            `ğŸ‘¤ ç”¨æˆ·ï¼š${ticket.firstName} (@${ticket.username})\n` +
            `ğŸ†” IDï¼š${ticket.userId}\n` +
            `ğŸ“‹ è®¢å•å·ï¼š${ticket.orderId}\n` +
            `â° æ—¶é—´ï¼š${ticket.time}`,
            { parse_mode: 'Markdown' }
          );
        } catch (e) {}
      }
      
      // å‘é€ç¾¤ç»„é“¾æ¥
      const keyboard = new InlineKeyboard()
        .url('âœ… åŠ å…¥ä¼šå‘˜ç¾¤', GROUP_LINK);
      
      await ctx.reply(
        `âœ… *è®¢å•éªŒè¯æˆåŠŸï¼*\n\n` +
        `æ¬¢è¿æˆä¸ºæˆ‘ä»¬çš„VIPä¼šå‘˜ï¼\n` +
        `è¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åŠ å…¥ä¼šå‘˜ç¾¤ï¼š`,
        {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        }
      );
    } else {
      // éªŒè¯å¤±è´¥
      const attempts = (userState.attempts || 0) + 1;
      
      if (attempts >= 2) {
        userStates.delete(userId);
        await ctx.reply(
          `âŒ éªŒè¯å¤±è´¥æ¬¡æ•°è¿‡å¤š\n` +
          `æ­£åœ¨è¿”å›ä¸»é¡µ...`
        );
        return ctx.reply('/start');
      }
      
      userStates.set(userId, { ...userState, attempts });
      await ctx.reply(
        `âŒ è®¢å•å·éªŒè¯å¤±è´¥\n` +
        `è¯·æ£€æŸ¥å¹¶é‡æ–°è¾“ï¿½ï¿½æ­£ç¡®çš„è®¢å•å·ï¼š`
      );
    }
  }
  
  // å•†å“æ·»åŠ æµç¨‹
  if (userState?.state === 'awaiting_keyword' && isAdmin(userId, ADMIN_IDS)) {
    const keyword = text;
    userStates.set(userId, {
      state: 'awaiting_content',
      keyword,
      contents: []
    });
    
    const keyboard = new InlineKeyboard()
      .text('âœ… å®Œæˆä¸Šæ¶', 'finish_product');
    
    await ctx.reply(
      `ğŸ“ å…³é”®è¯å·²è®°å½•ï¼š${keyword}\n\n` +
      `è¯·è¾“å…¥å†…å®¹ï¼ˆæ”¯æŒä»»æ„æ ¼å¼ï¼Œé€æ¡è®°å½•ï¼‰ï¼š`,
      { reply_markup: keyboard }
    );
  }
  
  if (userState?.state === 'awaiting_content' && isAdmin(userId, ADMIN_IDS)) {
    userState.contents.push({
      type: 'text',
      content: text
    });
    
    const keyboard = new InlineKeyboard()
      .text('âœ… å®Œæˆä¸Šæ¶', 'finish_product');
    
    await ctx.reply(
      `âœ… å·²æ·»åŠ ç¬¬ ${userState.contents.length} æ¡å†…å®¹\n` +
      `ç»§ç»­å‘é€æˆ–ç‚¹å‡»å®Œæˆï¼š`,
      { reply_markup: keyboard }
    );
  }
});

// å¤„ç†å›¾ç‰‡ï¼ˆFile IDï¼‰
bot.on('message:photo', async (ctx) => {
  const userId = ctx.from.id;
  const userState = userStates.get(userId);
  
  if (userState?.state === 'awaiting_file' && isAdmin(userId, ADMIN_IDS)) {
    const fileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
    userStates.delete(userId);
    
    await ctx.reply(
      `âœ… File ID è·å–æˆåŠŸï¼š\n\n` +
      `\`${fileId}\``,
      { parse_mode: 'Markdown' }
    );
    
    // è¿”å›adminé¢æ¿
    return ctx.reply('/admin');
  }
  
  // å•†å“å†…å®¹æ·»åŠ 
  if (userState?.state === 'awaiting_content' && isAdmin(userId, ADMIN_IDS)) {
    const fileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
    userState.contents.push({
      type: 'photo',
      content: fileId,
      caption: ctx.message.caption
    });
    
    const keyboard = new InlineKeyboard()
      .text('âœ… å®Œæˆä¸Šæ¶', 'finish_product');
    
    await ctx.reply(
      `âœ… å·²æ·»åŠ ç¬¬ ${userState.contents.length} æ¡å†…å®¹ï¼ˆå›¾ç‰‡ï¼‰\n` +
      `ç»§ç»­å‘é€æˆ–ç‚¹å‡»å®Œæˆï¼š`,
      { reply_markup: keyboard }
    );
  }
});

// å¤„ç†æ–‡ä»¶å’Œå…¶ä»–æ¶ˆæ¯ç±»å‹
bot.on(['message:document', 'message:video', 'message:audio'], async (ctx) => {
  const userId = ctx.from.id;
  const userState = userStates.get(userId);
  
  if (userState?.state === 'awaiting_content' && isAdmin(userId, ADMIN_IDS)) {
    const messageType = ctx.message.document ? 'document' : 
                       ctx.message.video ? 'video' : 'audio';
    const fileId = ctx.message[messageType].file_id;
    
    userState.contents.push({
      type: messageType,
      content: fileId,
      caption: ctx.message.caption
    });
    
    const keyboard = new InlineKeyboard()
      .text('âœ… å®Œæˆä¸Šæ¶', 'finish_product');
    
    await ctx.reply(
      `âœ… å·²æ·»åŠ ç¬¬ ${userState.contents.length} æ¡å†…å®¹ï¼ˆ${messageType}ï¼‰\n` +
      `ç»§ç»­å‘é€æˆ–ç‚¹å‡»å®Œæˆï¼š`,
      { reply_markup: keyboard }
    );
  }
});

// Admin callbacks
bot.callbackQuery('admin_fileid', async (ctx) => {
  await ctx.answerCallbackQuery();
  const userId = ctx.from.id;
  
  userStates.set(userId, { state: 'awaiting_file' });
  await ctx.editMessageText('ğŸ“ è¯·å‘é€å›¾ç‰‡ä»¥è·å–File IDï¼š');
});

bot.callbackQuery('admin_products', async (ctx) => {
  await ctx.answerCallbackQuery();
  return handleProductsMenu(ctx);
});

bot.callbackQuery('admin_tickets', async (ctx) => {
  await ctx.answerCallbackQuery();
  return handleTicketsMenu(ctx);
});

bot.callbackQuery('admin_users', async (ctx) => {
  await ctx.answerCallbackQuery();
  return handleUsersMenu(ctx);
});

// å•†å“ç®¡ç†
async function handleProductsMenu(ctx) {
  const products = await db.get('products') || {};
  const keywords = Object.keys(products);
  
  const keyboard = new InlineKeyboard();
  keyboard.text('â• ä¸Šæ¶æ–°å…³é”®è¯', 'add_product');
  
  if (keywords.length > 0) {
    keyboard.row();
    keywords.forEach(kw => {
      keyboard.text(`ğŸ—‘ ${kw}`, `del_product:${kw}`).row();
    });
  }
  
  await ctx.editMessageText(
    `ğŸ“¦ *å•†å“ç®¡ç†*\n\n` +
    `å½“å‰å…³é”®è¯ï¼š${keywords.length > 0 ? keywords.join(', ') : 'æš‚æ— '}`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
}

bot.callbackQuery('add_product', async (ctx) => {
  await ctx.answerCallbackQuery();
  const userId = ctx.from.id;
  
  userStates.set(userId, { state: 'awaiting_keyword' });
  await ctx.editMessageText('è¯·è¾“å…¥å…³é”®è¯ï¼š');
});

bot.callbackQuery('finish_product', async (ctx) => {
  await ctx.answerCallbackQuery();
  const userId = ctx.from.id;
  const userState = userStates.get(userId);
  
  if (userState?.state === 'awaiting_content') {
    const products = await db.get('products') || {};
    products[userState.keyword] = userState.contents;
    await db.set('products', products);
    
    userStates.delete(userId);
    
    await ctx.editMessageText(
      `âœ… å•†å“ä¸Šæ¶æˆåŠŸï¼\n\n` +
      `å…³é”®è¯ï¼š${userState.keyword}\n` +
      `å†…å®¹æ•°ï¼š${userState.contents.length}`
    );
    
    return ctx.reply('/admin');
  }
});

// å…‘æ¢åŠŸèƒ½
bot.callbackQuery('redeem', async (ctx) => {
  await ctx.answerCallbackQuery();
  return handleDH(ctx);
});

async function handleDH(ctx) {
  const userId = ctx.from.id;
  const userData = await initDB(userId);
  const products = await db.get('products') || {};
  const keywords = Object.keys(products);
  
  if (keywords.length === 0) {
    await ctx.reply(
      `ğŸ“¦ *æš‚æ— å¯å…‘æ¢å†…å®¹*\n\n` +
      `âœ¨ è¯·ç­‰å¾…ç®¡ç†å‘˜ä¸Šæ¶ âœ¨`,
      { parse_mode: 'Markdown' }
    );
    return;
  }
  
  // æ£€æŸ¥é¢‘ç‡é™åˆ¶
  const today = formatBeijingTime(new Date(), 'date');
  if (userData.date_key !== today) {
    // æ–°çš„ä¸€å¤©ï¼Œé‡ç½®è®¡æ•°
    userData.date_key = today;
    userData.daily_count = 0;
    userData.cooldown_index = 0;
    userData.last_use = null;
  }
  
  const isNewUser = userData.first_seen_date === today;
  const freeLimit = isNewUser ? 3 : 2;
  const cooldowns = [5, 10, 30, 40, 50]; // åˆ†é’Ÿ
  
  // æ£€æŸ¥å†·å´æ—¶é—´
  if (userData.last_use && userData.daily_count >= freeLimit) {
    const lastUse = new Date(userData.last_use);
    const cooldownMinutes = cooldowns[Math.min(userData.cooldown_index || 0, cooldowns.length - 1)];
    const cooldownEnd = new Date(lastUse.getTime() + cooldownMinutes * 60 * 1000);
    const now = new Date();
    
    if (now < cooldownEnd) {
      const remainingMinutes = Math.ceil((cooldownEnd - now) / 60000);
      const keyboard = new InlineKeyboard()
        .text('ğŸ’ åŠ å…¥ä¼šå‘˜ï¼ˆæ–°æ˜¥ç‰¹ä»·ï¼‰', 'vip_purchase')
        .row()
        .text('â†©ï¸ è¿”å›', 'back_start');
      
      await ctx.reply(
        `â° *å†·å´æ—¶é—´*\n\n` +
        `è¯·ç­‰å¾… ${remainingMinutes} åˆ†é’Ÿåå†è¯•\n` +
        `ä»Šæ—¥å·²ä½¿ç”¨ï¼š${userData.daily_count}/10 æ¬¡\n\n` +
        `ğŸ’ VIPä¼šå‘˜æ— é™åˆ¶ä½¿ç”¨`,
        {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        }
      );
      return;
    }
  }
  
  // æ£€æŸ¥æ¯æ—¥ä¸Šé™
  if (userData.daily_count >= 10) {
    const keyboard = new InlineKeyboard()
      .text('ğŸ’ åŠ å…¥ä¼šå‘˜ï¼ˆæ–°æ˜¥ç‰¹ä»·ï¼‰', 'vip_purchase')
      .row()
      .text('â†©ï¸ è¿”å›', 'back_start');
    
    await ctx.reply(
      `âŒ *ä»Šæ—¥æ¬¡æ•°å·²ç”¨å®Œ*\n\n` +
      `æ¯æ—¥ä¸Šé™ï¼š10 æ¬¡\n` +
      `æ˜æ—¥ 00:00 é‡ç½®\n\n` +
      `ğŸ’ VIPä¼šå‘˜æ— é™åˆ¶ä½¿ç”¨`,
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
    return;
  }
  
  // æ˜¾ç¤ºå…³é”®è¯åˆ—è¡¨ï¼ˆåˆ†é¡µï¼‰
  const page = 0;
  const pageSize = 10;
  const totalPages = Math.ceil(keywords.length / pageSize);
  const startIdx = page * pageSize;
  const pageKeywords = keywords.slice(startIdx, startIdx + pageSize);
  
  const keyboard = new InlineKeyboard();
  pageKeywords.forEach(kw => {
    keyboard.text(kw, `dh_get:${kw}`).row();
  });
  
  if (totalPages > 1) {
    keyboard.text('â–¶ï¸', `dh_page:1`);
  }
  
  await ctx.reply(
    `ğŸ *å…‘æ¢ä¸­å¿ƒ*\n\n` +
    `ğŸ“„ é¡µç ï¼š1/${totalPages}\n` +
    `å‰©ä½™å…è´¹æ¬¡æ•°ï¼š${Math.max(0, freeLimit - userData.daily_count)}/${freeLimit}\n` +
    `é€‰æ‹©è¦å…‘æ¢çš„å†…å®¹ï¼š`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
}

// å¤„ç†å…‘æ¢è¯·æ±‚
bot.callbackQuery(/^dh_get:(.+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const keyword = ctx.match[1];
  const userId = ctx.from.id;
  const userData = await initDB(userId);
  const products = await db.get('products') || {};
  
  if (!products[keyword]) {
    await ctx.reply('âŒ è¯¥å†…å®¹å·²ä¸‹æ¶');
    return;
  }
  
  // æ›´æ–°ä½¿ç”¨è®°å½•
  userData.daily_count = (userData.daily_count || 0) + 1;
  userData.last_use = new Date().toISOString();
  
  if (userData.daily_count > (userData.first_seen_date === formatBeijingTime(new Date(), 'date') ? 3 : 2)) {
    userData.cooldown_index = Math.min((userData.cooldown_index || 0) + 1, 4);
  }
  
  await db.set(`user:${userId}`, userData);
  
  // å‘é€å†…å®¹ï¼ˆåˆ†ç»„ï¼‰
  const contents = products[keyword];
  const groups = [];
  for (let i = 0; i < contents.length; i += 10) {
    groups.push(contents.slice(i, i + 10));
  }
  
  // å‘é€ç¬¬ä¸€ç»„
  await sendContentGroup(ctx, groups[0], 1, groups.length, keyword);
});

async function sendContentGroup(ctx, contents, groupIndex, totalGroups, keyword) {
  for (let i = 0; i < contents.length; i++) {
    const item = contents[i];
    const progress = `ğŸ“¦ æ–‡ä»¶ ${i + 1}/${contents.length}`;
    
    try {
      switch (item.type) {
        case 'text':
          await ctx.reply(`${progress}\n\n${item.content}`);
          break;
        case 'photo':
          await ctx.replyWithPhoto(item.content, {
            caption: item.caption ? `${progress}\n\n${item.caption}` : progress
          });
          break;
        case 'document':
          await ctx.replyWithDocument(item.content, {
            caption: item.caption ? `${progress}\n\n${item.caption}` : progress
          });
          break;
        case 'video':
          await ctx.replyWithVideo(item.content, {
            caption: item.caption ? `${progress}\n\n${item.caption}` : progress
          });
          break;
        case 'audio':
          await ctx.replyWithAudio(item.content, {
            caption: item.caption ? `${progress}\n\n${item.caption}` : progress
          });
          break;
      }
    } catch (e) {
      console.error('å‘é€å†…å®¹å¤±è´¥:', e);
    }
  }
  
  // å‘é€å®Œæˆæç¤º
  if (groupIndex < totalGroups) {
    const keyboard = new InlineKeyboard()
      .text('âœ¨ğŸ‘‰ è¯·ç‚¹å‡»ç»§ç»­å‘é€', `continue_send:${keyword}:${groupIndex}`)
      .row()
      .text('â†©ï¸ è¿”å›å…‘æ¢', 'redeem');
    
    await ctx.reply(
      `ğŸ“¦ ç¬¬ ${groupIndex} ç»„å‘é€å®Œæˆ\n` +
      `å‰©ä½™ ${totalGroups - groupIndex} ç»„å¾…å‘é€`,
      { reply_markup: keyboard }
    );
  } else {
    const keyboard = new InlineKeyboard()
      .text('ğŸ’ åŠ å…¥ä¼šå‘˜ï¼ˆæ–°æ˜¥ç‰¹ä»·ï¼‰', 'vip_purchase')
      .row()
      .text('â†©ï¸ è¿”å›å…‘æ¢', 'redeem');
    
    await ctx.reply(
      `âœ… æ–‡ä»¶å‘é€å®Œæ¯•\n` +
      `å…± ${totalGroups} ç»„å†…å®¹å·²å…¨éƒ¨å‘é€`,
      { reply_markup: keyboard }
    );
  }
}

// å·¥å•ç®¡ç†
async function handleTicketsMenu(ctx, page = 0) {
  const tickets = await db.get('tickets') || [];
  const pageSize = 10;
  const totalPages = Math.ceil(tickets.length / pageSize);
  const startIdx = page * pageSize;
  const pageTickets = tickets.slice(startIdx, startIdx + pageSize);
  
  if (tickets.length === 0) {
    await ctx.editMessageText('ğŸ“‹ æš‚æ— å·¥å•');
    return;
  }
  
  const keyboard = new InlineKeyboard();
  
  pageTickets.forEach((ticket, idx) => {
    const displayName = ticket.username ? `@${ticket.username}` : ticket.firstName;
    keyboard.text(
      `${displayName}(${ticket.userId})`,
      `ticket_detail:${startIdx + idx}`
    ).row();
  });
  
  // åˆ†é¡µæŒ‰é’®
  const navButtons = [];
  if (page > 0) navButtons.push(['â—€ï¸', `tickets_page:${page - 1}`]);
  if (page < totalPages - 1) navButtons.push(['â–¶ï¸', `tickets_page:${page + 1}`]);
  
  if (navButtons.length > 0) {
    keyboard.row();
    navButtons.forEach(([text, data]) => keyboard.text(text, data));
  }
  
  keyboard.row().text('â†©ï¸ è¿”å›', 'back_admin');
  
  await ctx.editMessageText(
    `ğŸ“‹ *å·¥å•åˆ—è¡¨*\n` +
    `ğŸ“„ é¡µç ï¼š${page + 1}/${totalPages}\n` +
    `æ€»è®¡ï¼š${tickets.length} ä¸ªå·¥å•`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
}

// å·¥å•è¯¦æƒ…
bot.callbackQuery(/^ticket_detail:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const idx = parseInt(ctx.match[1]);
  const tickets = await db.get('tickets') || [];
  const ticket = tickets[idx];
  
  if (!ticket) {
    await ctx.reply('âŒ å·¥å•ä¸å­˜åœ¨');
    return;
  }
  
  const keyboard = new InlineKeyboard()
    .text('ğŸ—‘ åˆ é™¤å·¥å•', `delete_ticket:${idx}`)
    .row()
    .text('â†©ï¸ è¿”å›', 'admin_tickets');
  
  await ctx.editMessageText(
    `ğŸ“‹ *å·¥å•è¯¦æƒ…*\n\n` +
    `ğŸ‘¤ ç”¨æˆ·åå­—ï¼š${ticket.firstName}\n` +
    `ğŸ‘¤ ç”¨æˆ·åï¼š@${ticket.username || 'Unknown'}\n` +
    `ğŸ†” ç”¨æˆ·IDï¼š${ticket.userId}\n` +
    `ğŸ“‹ è®¢å•ç¼–å·ï¼š${ticket.orderId}\n` +
    `â° æäº¤æ—¶é—´ï¼š${ticket.time}\n` +
    `ğŸ“Š çŠ¶æ€ï¼š${ticket.status === 'pending' ? 'å¾…å¤„ç†' : 'å·²å¤„ç†'}`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
});

// åˆ é™¤å·¥å•
bot.callbackQuery(/^delete_ticket:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const idx = parseInt(ctx.match[1]);
  const tickets = await db.get('tickets') || [];
  
  if (idx < tickets.length) {
    tickets.splice(idx, 1);
    await db.set('tickets', tickets);
    await ctx.editMessageText('âœ… å·¥å•å·²åˆ é™¤');
    return handleTicketsMenu(ctx);
  }
});

// ç”¨æˆ·åˆ—è¡¨
async function handleUsersMenu(ctx, page = 0) {
  const users = await db.get('all_users') || [];
  const pageSize = 10;
  const totalPages = Math.ceil(users.length / pageSize);
  const startIdx = page * pageSize;
  const pageUsers = users.slice(startIdx, startIdx + pageSize);
  
  if (users.length === 0) {
    await ctx.editMessageText('ğŸ‘¥ æš‚æ— ç”¨æˆ·æ•°æ®');
    return;
  }
  
  const keyboard = new InlineKeyboard();
  
  pageUsers.forEach(userId => {
    keyboard.text(`ğŸ‘¤ ${userId}`, `user_detail:${userId}`).row();
  });
  
  // åˆ†é¡µ
  const navButtons = [];
  if (page > 0) navButtons.push(['â—€ï¸', `users_page:${page - 1}`]);
  if (page < totalPages - 1) navButtons.push(['â–¶ï¸', `users_page:${page + 1}`]);
  
  if (navButtons.length > 0) {
    keyboard.row();
    navButtons.forEach(([text, data]) => keyboard.text(text, data));
  }
  
  keyboard.row().text('â†©ï¸ è¿”å›', 'back_admin');
  
  await ctx.editMessageText(
    `ğŸ‘¥ *ç”¨æˆ·åˆ—è¡¨*\n` +
    `ğŸ“„ é¡µç ï¼š${page + 1}/${totalPages}\n` +
    `æ€»è®¡ï¼š${users.length} ä¸ªç”¨æˆ·`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
}

// ç”¨æˆ·è¯¦æƒ…
bot.callbackQuery(/^user_detail:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const userId = ctx.match[1];
  const userData = await db.get(`user:${userId}`) || {};
  
  const keyboard = new InlineKeyboard()
    .text('â†©ï¸ è¿”å›', 'admin_users');
  
  const isBlocked = userData.blocked || false;
  const statusText = isBlocked ? 'ğŸ”´ å·²åœç”¨' : 'ğŸŸ¢ æ­£å¸¸';
  
  await ctx.editMessageText(
    `ğŸ‘¤ *ç”¨æˆ·è¯¦æƒ…*\n\n` +
    `ğŸ†” ç”¨æˆ·IDï¼š${userId}\n` +
    `ğŸ“… é¦–æ¬¡ä½¿ç”¨ï¼š${userData.first_seen || 'æœªçŸ¥'}\n` +
    `ğŸ“… æœ€è¿‘æ´»åŠ¨ï¼š${userData.last_use || 'æœªçŸ¥'}\n` +
    `ğŸ“Š çŠ¶æ€ï¼š${statusText}\n` +
    `ğŸ ä»Šæ—¥å…‘æ¢ï¼š${userData.daily_count || 0} æ¬¡`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
});

// /c å‘½ä»¤ - å–æ¶ˆå½“å‰æ“ä½œ
bot.command('c', async (ctx) => {
  const userId = ctx.from.id;
  
  if (isAdmin(userId, ADMIN_IDS)) {
    userStates.delete(userId);
    await ctx.reply('âœ… å·²å–æ¶ˆå½“å‰æ“ä½œ');
  }
});

// /cz å‘½ä»¤ - é‡ç½®ç®¡ç†å‘˜æµ‹è¯•æ•°æ®
bot.command('cz', async (ctx) => {
  const userId = ctx.from.id;
  
  if (!isAdmin(userId, ADMIN_IDS)) {
    return;
  }
  
  const userData = await initDB(userId);
  userData.daily_count = 0;
  userData.cooldown_index = 0;
  userData.last_use = null;
  userData.first_seen_date = formatBeijingTime(new Date(), 'date');
  userData.date_key = formatBeijingTime(new Date(), 'date');
  
  await db.set(`user:${userId}`, userData);
  await ctx.reply('âœ… æµ‹è¯•æ•°æ®å·²é‡ç½®ï¼Œæ‚¨ç°åœ¨æ˜¯"æ–°ç”¨æˆ·"çŠ¶æ€');
});

// è¿”å›æŒ‰é’®å¤„ç†
bot.callbackQuery('back_admin', async (ctx) => {
  await ctx.answerCallbackQuery();
  return ctx.reply('/admin');
});

bot.callbackQuery('back_start', async (ctx) => {
  await ctx.answerCallbackQuery();
  return ctx.reply('/start');
});

// åˆ†é¡µå¤„ç†
bot.callbackQuery(/^tickets_page:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const page = parseInt(ctx.match[1]);
  return handleTicketsMenu(ctx, page);
});

bot.callbackQuery(/^users_page:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const page = parseInt(ctx.match[1]);
  return handleUsersMenu(ctx, page);
});

bot.callbackQuery(/^dh_page:(\d+)$/, async (ctx) => {
  await ctx.answerCallbackQuery();
  // å®ç°å…‘æ¢åˆ—è¡¨åˆ†é¡µ
});

// /p å‘½ä»¤
bot.command('p', async (ctx) => {
  if (!isAdmin(ctx.from.id, ADMIN_IDS)) {
    return;
  }
  return handleProductsMenu(ctx);
});

// /dh å‘½ä»¤
bot.command('dh', async (ctx) => {
  return handleDH(ctx);
});

// /v å‘½ä»¤ï¼ˆVIPè´­ä¹°ï¼‰
bot.command('v', async (ctx) => {
  const keyboard = new InlineKeyboard()
    .text('âœ… æˆ‘å·²ä»˜æ¬¾ï¼Œå¼€å§‹éªŒè¯', 'verify_payment');
  
  await ctx.reply(
    `ğŸŠ *å–œè¿æ–°æ˜¥ç‰¹ä»·* ğŸŠ\n\n` +
    `ğŸ’ *VIPä¼šå‘˜ç‰¹æƒè¯´æ˜ï¼š*\n` +
    `âœ… ä¸“å±ä¸­è½¬é€šé“\n` +
    `âœ… ä¼˜å…ˆå®¡æ ¸å…¥ç¾¤\n` +
    `âœ… 7x24å°æ—¶å®¢æœæ”¯æŒ\n` +
    `âœ… å®šæœŸç¦åˆ©æ´»åŠ¨`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    }
  );
});

// Webhook handler for Vercel
export default async (req, res) => {
  try {
    if (req.method === 'POST') {
      await bot.handleUpdate(req.body);
      res.status(200).json({ ok: true });
    } else {
      res.status(200).json({ status: 'Bot is running' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
};
